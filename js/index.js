// Generated by CoffeeScript 2.3.0
var S_IFDIR, S_IFLNK, S_IFMT, S_IFREG, defer, errno, follow, fs, getMode, lstat, os, path, readFile, readlink, resolve, uhoh;

({S_IFMT, S_IFREG, S_IFDIR, S_IFLNK} = require('fs').constants);

({lstat, readlink, readFile} = require('graceful-fs'));

errno = require('./errno');

path = require('path');

os = require('os');

fs = exports;

fs.read = async function(name, enc) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    uhoh(`Path does not exist: '${name}'`, 'NOT_REAL');
  }
  if (mode === S_IFDIR) {
    uhoh(`Path is not readable: '${name}'`, 'NOT_FILE');
  }
  if (enc === void 0) {
    enc = "utf8";
  }
  return defer(readFile, name, enc);
};

fs.follow = async function(name, recursive) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    uhoh(`Path does not exist: '${name}'`, 'NOT_REAL');
  }
  if (mode === S_IFLNK) {
    return follow(name, recursive);
  } else {
    return Promise.resolve(name);
  }
};


// Internal

uhoh = function(msg, why) {
  var err;
  err = Error(msg);
  err.code = errno[why] || 0;
  Error.captureStackTrace(err, uhoh);
  throw err;
};

resolve = function(name) {
  if (name[0] === '~') {
    return os.homedir() + name.slice(1);
  } else {
    return path.resolve(name);
  }
};

getMode = async function(name) {
  var e;
  try {
    return ((await defer(lstat, name))).mode & S_IFMT;
  } catch (error) {
    e = error;
    return null;
  }
};

defer = function(callee, $1, $2) {
  var n;
  n = arguments.length - 1;
  return new Promise(function(resolve, reject) {
    var done;
    done = function(err, data) {
      if (err) {
        return reject(err);
      } else {
        return resolve(data);
      }
    };
    switch (n) {
      case 0:
        return callee(done);
      case 1:
        return callee($1, done);
      case 2:
        return callee($1, $2, done);
    }
  });
};

// Recursive symlink resolution
follow = function(link, recursive) {
  return new Promise(function(resolve, reject) {
    var next, prev, reads, validate;
    prev = link;
    reads = 1;
    if (typeof recursive === 'function') {
      validate = recursive;
      recursive = true;
    }
    return readlink(link, next = async function(err, name) {
      var mode;
      if (err) {
        return reject(err);
      }
      if (!path.isAbsolute(name)) {
        name = path.resolve(path.dirname(prev), name);
      }
      if (validate && !((await validate(name)))) {
        return resolve(prev);
      } else if (!recursive) {
        return resolve(name);
      } else if (!(mode = (await getMode(name)))) {
        err = Error(`Symlink leads nowhere: '${link}'`);
        err.code = errno.NOT_REAL;
        return reject(err);
      } else if (mode !== S_IFLNK) {
        return resolve(name);
      } else if (reads !== 10) {
        prev = name;
        reads++;
        return readlink(name, next);
      } else {
        err = Error(`Too many symlinks: '${link}'`);
        err.code = errno.LINK_LIMIT;
        return reject(err);
      }
    });
  });
};

(function() {  // Expose error codes.
  var def, des, why;
  def = Object.defineProperty;
  des = {
    value: 0
  };
  for (why in errno) {
    des.value = errno[why];
    def(fs, why, des);
  }
})();
